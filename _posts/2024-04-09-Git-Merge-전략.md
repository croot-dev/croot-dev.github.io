---
layout: post
title: "Git Merge 전략"
created: 2024-04-09
edited: 2024-04-12
category: [기술]
tags: [Git:rgb(227 226 224):rgb(50 48 44)]
---


## **Git 병합 전략: 어떤 것을 선택해야 할까?**


Git을 사용하면서 브랜치를 관리하고 변경 사항을 통합하는 것은 중요한 작업입니다.


이를 위해 다양한 병합 전략이 제공되며, 이 글에서는 주요한 병합 전략인 `Fast-Forward`, `Merge Commit`, `Rebase`, `Squash`, `Octopus`를 살펴보고, 어떤 상황에서 어떤 전략을 선택해야 하는지에 대해 알아보겠습니다.


## Git 병합 전략 유형


### **Fast-Forward 병합**


![0](/assets/img/2024-04-09-Git-Merge-전략.md/0.png)_Untitled.png_


변경 사항이 충돌이 없는 경우에 사용. 브랜치를 단순히 이동시키는 것으로 변경 사항을 통합합니다.


**[장점]**

- 히스토리를 깔끔하게 유지
- 간단하게 병합할 수 있음

**[단점]**

- 이전 커밋들의 의미가 불분명해질 수 있으며, 병합 결과를 추적하기가 어려움

**[사용사례]**

- 기능 개발이 완료되어 개발 브랜치를 메인 브랜치에 통합할 때 사용될 수 있습니다.

### **Merge Commit (Recursive) 병합**


![1](/assets/img/2024-04-09-Git-Merge-전략.md/1.png)_Untitled.png_


Merge Commit 병합은 두 브랜치를 병합할 때 새로운 병합 커밋을 생성하여 변경 내용을 합칩니다.


**[장점]**

- 변경 사항을 명확하게 추적할 수 있다.
- 충돌이 발생할 경우 쉽게 해결할 수 있다.

**[단점]**

- 불필요한 병합 커밋이 생성되어 히스토리가 어지러워질 수 있음

**[사용사례]**

- 여러 개발자가 동시에 작업하여 각각의 기능이나 작업이 명시적으로 추적되어야 할 때 사용됩니다.

### **Rebase 병합**


![2](/assets/img/2024-04-09-Git-Merge-전략.md/2.png)_Untitled.png_


Rebase 병합은 현재 브랜치의 변경 사항을 다른 브랜치의 변경 사항 뒤로 옮겨서 병합합니다.


각 커밋은 새로운 커밋 Hash가 생성됩니다.


**[장점]**

- 커밋 히스토리를 깔끔하게 유지할 수 있다.
- 변경 사항을 선형적으로 추적할 수 있다.

**[단점]**

- 이미 공유된 커밋을 리베이스하면 충돌이 발생하고 강제 푸시가 필요하다.
- 과도한 리베이스는 히스토리를 혼란스럽게 할 수 있다.

**[사용사례]**

- 메인 브랜치에 있는 최신 변경 사항을 로컬 브랜치에 반영하고자 할 때 사용될 수 있습니다.

### **Squash 병합**


![3](/assets/img/2024-04-09-Git-Merge-전략.md/3.png)_Untitled.png_


Squash 병합은 여러 개의 커밋을 하나의 커밋으로 합치는 방식입니다. 


**[장점]**

- 불필요한 커밋이 생성되지 않아 히스토리를 간결하게 유지한다.

**[단점]**

- 각각의 작업이 명확하게 추적되지 않는다.
- 충돌이 발생할 경우 해결이 복잡할 수 있다.

**[사용사례]**

- 여러 개의 작은 커밋을 하나로 합쳐야 할 때 사용될 수 있습니다. 
예를 들어, 코드 리뷰 이후에 개발 브랜치를 메인 브랜치로 통합할 때 사용될 수 있습니다.

### **Octopus 병합 (ORT; Octopus Recursive Threes)**


Octopus 병합은 세 개 이상의 브랜치를 한 번에 병합하는 방식입니다. 아래 이해를 돕기 위한 단순한 그림이 있습니다.


**(일반 Merge 경우)**


![4](/assets/img/2024-04-09-Git-Merge-전략.md/4.png)_Untitled.png_


**(Octopus Merge 경우)**


![5](/assets/img/2024-04-09-Git-Merge-전략.md/5.png)_Untitled.png_


**[장점]**

- 여러 브랜치를 한 번에 병합할 수 있어 효율적이다.

**[단점]**

- 복잡한 충돌이 발생할 가능성이 있다.
- 히스토리가 복잡해지고 추적하기 어려울 수 있습니다.

**[사용사례]**

- 여러 기능을 동시에 개발하고 병합할 때 사용될 수 있습니다.
예를 들어, 다수의 기능을 개발한 후 이를 한 번에 메인 브랜치로 통합할 때 사용될 수 있습니다.

## 전략 별 비교 표


| **병합 전략**    | **특징**                     | **장점**           | **단점**                        | **사용사례**           |
| ------------ | -------------------------- | ---------------- | ----------------------------- | ------------------ |
| Fast-Forward | 히스토리를 유지하면서 브랜치를 단순하게 병합   | 히스토리 유지, 간단한 병합  | 변경 내용의 의미가 불분명할 수 있음          | 개발 브랜치 → 메인브랜치 반영  |
| Merge Commit | 명시적인 병합 커밋을 생성하여 변경 내용을 병합 | 변경 내용 추적         | 불필요한 병합 커밋 생성 가능              | 다수의 작업 추적          |
| Rebase       | 변경 사항을 선형적으로 유지하면서 병합      | 깔끔한 히스토리, 선형적 추적 | 충돌 발생 시 처리가 복잡할 수 있음          | 메인 브랜치 → 로컬 브랜치 반영 |
| Squash       | 여러 개의 커밋을 하나로 합침           | 히스토리 간결화         | 각 작업 추적이 어려움, 충돌 발생 시 처리가 복잡함 | 여러 작은 커밋 합칠 시      |
| Octopus      | 여러 브랜치를 한 번에 병합하는 방식       | 효율적 병합           | 복잡한 충돌 가능성, 히스토리가 복잡해질 수 있음   | 여러 기능 동시 개발 후 병합   |


## **어떤 전략을 선택해야 할까?**


프로젝트의 요구 사항과 개발 팀의 작업 스타일에 따라 가장 적합한 전략을 선택해야 합니다.


종종 이러한 전략을 혼합하여 사용하기도 한다. 중요한 것은 프로젝트의 효율성을 높이고 히스토리를 명확하게 유지하는 것입니다.


(하지만 ORT 전략은 되도록 쓰지 않을 듯 싶다…)

